\documentclass[12pt,titlepage]{article}
\usepackage[margin=1in]{geometry}
\usepackage{amsmath}
\usepackage{parskip}

\usepackage{hyperref}
\hypersetup{
  linktoc=all
}

\begin{document}
  \begin{titlepage}
    \vspace*{\fill}
    \centering

    \textbf{\Huge SE 463 Course Notes} \\ [0.4em]
    \textbf{\Large Software Requirements Specification and Analysis} \\ [1em]
    \textbf{\Large Michael Socha} \\ [1em]
    \textbf{\large 4A Software Engineering} \\
    \textbf{\large University of Waterloo} \\
    \textbf{\large Spring 2018} \\
    \vspace*{\fill}
  \end{titlepage}

  \newpage 

  \pagenumbering{roman}

  \tableofcontents

  \newpage

  \pagenumbering{arabic}

  \section{Course Overview}
    \subsection{Logistics}
      \begin{itemize}
        \item \textbf{Professor:} Joanne Atlee
      \end{itemize}

    \subsection{Overview of Topics}
      Many software project failures are not due to technical reasons, but rather due to poor project specifications. This course
      focuses on requirement-related topics including:
      \begin{itemize}
        \item Different types of requirements
        \item Learning about stakeholder needs
        \item Analyzing and refining preliminary requirements
        \item Expressing requirements in various representations
        \item Managing requirement changes
      \end{itemize}

  \newpage

  \section{Business Model}
    \subsection{Traditional Product Model}
      A traditional ``waterfall'' style of development relies heavily on the initial implementation meeting customer needs. This
      approach often leads to requirement-related problems, since the business and development team might not understand the
      customer needs or the customer needs might change, and a waterfall model offers little room to refine these requirements.

    \subsection{Lean Product Development Model}
      A lean product development model focuses on first determining whether a project addresses an important problem (e.g. problem
      fit), and whether the project provides a solution people want (market fit). Only after these are established is a product built,
      which is usually nimble at first and then scales up.

    \subsection{Lean Canvas}
      A lean canvas is a template to help determine the initial requirements for a project, especially one in the new product or
      consulting space. The sections of a lean canvas are described below:

      \subsubsection{Customer Segments}
        This is a list of potential customers and users. It helps to have granular segments, and focus should be placed on segments likely
        to become early adopters.

      \subsubsection{Problem Segments}
        This is a list of a few top problems that each customer segment wants solved.

      \subsubsection{Unique Value Proposition}
        This is a reason why the project is unique and valuable. The focus should also be on early adopters.

      \subsubsection{Solution}
        This is a list of solutions early adopters already apply to solve this problem. From this list, some key capabilities and features
        of the software project can be determined.

      \subsubsection{Channels}
        This is a list of methods to reach the project's target customers. This is important to consider early, since these customers
        are not just useful as end users, but also as subjects of testing and experiments during development.

      \subsubsection{Revenue Streams and Costs}
        Revenue and costs should be considered early in a project. If the project is going to operate on a subscription model, it is
        a good idea to charge something from the start (with the exception of a free trial period). ``Freemium'' business models, in
        which core services are free, tend to have low conversion rates to paying features.

      \subsubsection{Key Metrics}
        This is a list of metrics to be used for measuring success.

      \subsubsection{Unfair Advantage}
        This refers to some sort of competitive advantage that is hard to replicate. Examples include an existing reputation or customer
        base, proprietary data, or patented work.

  \newpage

  \section{Hypothesis Testing}
    Purpose of hypothesis testing is to validate or disprove guesses in a project's business model. Hypothesis testing is generally
    conducted by performing pass/fail experiments through market research or customer interviews. Hypothesis being disproved can lead
    to learning, after which the hypothesis can be pivoted based on new understanding.

    \subsection{Hypothesis}
      A hypothesis is a tentative guess about a phenomenon of interest that is testable and falsifiable. The phenomenon of interest
      (e.g. characteristic of customer problem) are considered to be dependent variables, while independent variables affect the
      phenomenon of interest. A good hypothesis must be testable (i.e. possible to observe effects of independent variables on
      dependent variables) and falsifiable.

      \subsection{Falsifiable Hypothesis}
        A falsifiable hypothesis is a statement that can easily be proven wrong. Specific and testable statements are more falsifiable
        than vague ones. Falsifiable hypothesis often have somewhat of a universally quantification aspect (e.g. all, most, etc), rather
        than merely existential quantification.

    \subsection{Testing Risks}
      Uncertainty simply means that there are multiple possibilities. Risk tends to involve uncertainty, with some of the possibilities
      leading to failure. The three largest risks to a project are:

        \subsubsection{Customer Risk}
          e.g. Is there a viable customer segment, and what are their risks?

        \subsubsection{Product Risk}
          e.g. How do customers rank the top three problems?

        \subsubsection{Market Risk}
          e.g. How do customers solve these problems today?

    \subsection{Problem Interview}
      Interviews will generally follow the order below:
      \begin{itemize}
        \item Welcome
        \item Collect demographics (i.e. test customer segment)
        \item Tell a story (i.e. set a problem context)
        \item Problem ranking
        \item Explore customer's worldview
        \item Wrapping up (i.e. hook and ask)
        \item Document results
      \end{itemize}

    \subsection{Processing Results}
      It is important to home in on early adopters. As more information is gathered, it may help to refine the problem or pivot the hypothesis.
      It helps to continue gathering results until they are fairly consistent. Good indications that enough testing has been done are that
      you can identify the demographics of an early adopter, have a must-have (i.e. critical problem to work on first) problem, and can describe
      how customers currently solve this problem.

  \newpage

  \section{Stakeholders}
    A stakeholder is considered to be anyone who has a stake in a project's ultimate success or failure. Stakeholders an include the development
    team, people in the operational work area, the containing business, and forces from the outside world.

    \subsection{Owners/Clients/Champions}
      The owner/client is the group paying for the software to be developed. They are usually considered to be the ultimate/champion stakeholder,
      since they often have the final say in a project. Examples include a client in a consultancy project, or the company developers are working
      for in an internal project.

    \subsection{Customers}
      A customer buys a project after its completion. The customer may be the same person as the owner or user.

    \subsection{Users}
      Users tends to be experts on the work the system is performing, and experts on any existing systems or competing products. Users typically
      have specific needs a product should satisfy.

      \subsubsection{User Classes}
        To meet various user needs, it helps to categorize users by their differences, including:
        \begin{itemize}
          \item Access privilege and security levels
          \item Tasks regularly performed
          \item Features used
          \item Frequency of use
          \item Application domain expertise, technical expertise
          \item Platform of use
          \item Preferred language
          \item Disfavored users (users who should not have access for security, legal or safety reasons, such as kids on some social media platforms)
        \end{itemize}

    \subsection{Personas}
      Personas are resemblances of actual users that can be constructed when real users are hard to interview (e.g. not numerous, too numerous). Personas
      should imitate the key details of important user classes. Enough details should be provided to make the persona seem realistic. Effectively built
      personas can:
      \begin{itemize}
        \item Guard against building a product just from the developer's perspective
        \item Guard against adapting to ``elastic'' users, and instead focus on keeners and early adopters
      \end{itemize}

    \subsection{Domain Expert}
      Domain experts understand the problem domain very well, and familiar with typical users, their expectations, and potential deployment environments.
      Note that domain experts need not know much about software engineering.

    \subsection{Software Engineer}
      A software engineering is an expert on the project's development technologies. These stakeholders can represent the development teams they run, and
      are responsible for overseeing the progress of the technical and some economic aspects of the project. Software engineering can also educate customers
      how available technology can affect the requested functionality.

    \subsection{Other Stakeholders}
      Other potential stakeholders include:
      \begin{itemize}
        \item \textbf{Inspectors:} Experts on government and safety regulations
        \item \textbf{Market researchers:} Can serve as proxy for customer interviews
        \item \textbf{Lawyers:} Familiar with legal requirements and licensing
        \item \textbf{Experts on adjacent systems:} Can explain how adjacent systems can affect the project
        \item \textbf{Negative stakeholders:} Stakeholders that want a project to fail
      \end{itemize}

  \newpage

  \section{User Requirements}

    \subsection{Use Cases}
      A use case represents some sort of end-to-end functionality in a system, capturing both its triggering event and the complete system response. Well-defined
      use cases should not overlap much with one another. Time-triggered use cases feature time as their triggering event.

      \subsection{Actors}
        An actor is an entity that interacts with the described system, which may include users or other systems. A supporting actor provides some service to the
        described system.

        \subsubsection{Actor Generalization}
          Actors often share common use cases with one another. In these cases, actor generalization can be applied, which factors out common behavior as an
          abstract actor.

      \subsection{Modifying Use Cases}
        \begin{itemize}
          \item <<include>> is used to add a sub use case that is used in multiple other use cases
          \item <<extend>> is used to add a sub use case that is used in multiple other use cases
        \end{itemize}
        Note that well-described systems tend to use these modifiers sparingly.

      \subsection{Use-Case Descriptions}
        Textual formats known as use-case descriptions are commonly used to represent use-cases. These descriptions vary in the amount of detail provided for
        each use case.

      \subsection{User Stories}
        User stories are an alternative to use-case descriptions for describing a system. Instead of being told from the system's perspective, user stories
        provide a description of something a user wants to be able to do (i.e. user requirements). The parts of a successfully managed user story are:
        \begin{itemize}
          \item \textbf{Card:} The initial description, often phrased as ``As a <role>, I want <something> so that <benefit>''
          \item \textbf{Conversation:} Discussion with product owner to determine requirement details
          \item \textbf{Confirmation:} Criteria for determining whether implementation meets requirements (conditions of satisfaction are described
          from the system's perspective)
        \end{itemize}

        \subsubsection{Benefits of User Stories}
          The benefits of user stories include:
          \begin{itemize}
            \item Easy for stakeholders to understand
            \item User-focused style encourages discussion more than ordinary written documentation
            \item Encouraging iterative development when stories are sized accordingly
          \end{itemize}

      \subsection{Changing Requirements}
        System requirements often change during the development process. Below are key topics to consider when managing requirement changes.

        \subsubsection{Requirements Baseline}
          A requirements baseline is a set of formally reviewed and agreed core requirements for a system. Major requirement changes should pass
          through this review process, and it may be helpful to limit the rate of change to these requirements.

        \subsubsection{Unique Value Proposition (UVP)}
          New requirements should not weaken a project's UVP.

        \subsubsection{Project Scope}
          When project scope is not managed well, there is a tendency for ``scope creep'' to occur. Scope creep can be mitigated by keeping a
          prioritized list of requirements, and only adding a few major ones to each release.

  \newpage

  \section{Workflow Models}
    A use case can be decomposed into an ordered sequence of tasks known as a workflow. Each task in a workflow specifies the data it requires
    and the data it produces.

    \subsection{Scenarios}
      A scenario is one full execution path through a use case, listing only observable actions between a system and external actors. A use case can
      be considered to be a collection of success and failure scenarios initiated by an external actor to achieve a particular goal. An example scenario
      for a banking system is below:
      \begin{enumerate}
        \item User requests to withdraw funds, specifies amount
        \item Bank authenticates user
        \item Bank checks account has sufficient funds
        \item Bank dispenses cash and receipt
        \item Bank records the transaction
        \item User takes case and receipt, leaves
      \end{enumerate}

      A general template for a scenario includes:
      \begin{itemize}
        \item \textbf{Business event name}
        \item \textbf{Business use case name/reference}
        \item \textbf{Trigger}
        \item \textbf{Preconditions}
        \item \textbf{Interested stakeholders}
        \item \textbf{Active stakeholders}
        \item \textbf{Normal case steps}
        \item \textbf{Alternatives} - Sub use cases that capture the main goal of this use case through a different sequence of actions
        \item \textbf{Exceptions} - Sub use cases that capture an unwanted deviation
        \item \textbf{Postconditions}
      \end{itemize}

      \subsubsection{More Complex Actions}
        Scenario actions can include more complex control flow, such as branching and looping. However, this should be used sparingly, and is
        often a good indicator that the scenario is becoming too detailed or all-encompassing.

    \subsection{Workflow Diagrams}
      \subsubsection{Activity Diagram}
        Activity diagrams are UML graphical representations of a system's flow control between activities and actions.

      \subsubsection{Dataflow Diagram (DFD)}
        DFDs are graphical representations of the functional decomposition of an information system. Each step in a described workflow
        states what information it requires along with its source, and what information is produced along with its destination.

  \newpage

  \section{MVP (Minimum Viable Product) Hypothesis Testing}
    It is important to run experiments to assess the risks of a solution. Areas of risk to assess include customer risk (e.g. who the
    early adopters are, how they will be reached), and product risk (e.g. whether the solution and UVP align with the customers' main
    problem, and what the minimum set of features required to launch is).

    \subsection{Solution Interview}
      \subsubsection{Interview Flow}
        An interview designed to test the risks of a MVP solution can follow the general flow below:
        \begin{enumerate}
          \item \textbf{Welcome:} Set the stage for how the interview works.
          \item \textbf{Collect demographics:} Try to determine how the interviewee approaches the problem at hand (e.g. for a job search platform,
          learn about their job search habits).
          \item \textbf{Tell a story:} Illustrate the top problems the MVP is trying to solve through a brief story.
          \item \textbf{Demo (Test Solution):} For each problem, go through the workflow and determine whether it addresses the interviewee's main
          problems. This may appear to be a pitch, but its goal is learning more so than marketing. Attention should be paid to the interviewee's
          attitude and reactions. Unexpected reactions provide great learning opportunities and should be examined.
          \item \textbf{Wrapping up:} Ask for permission to follow up, as well as for referrals for other prospective interviewees.
        \end{enumerate}

      \subsubsection{Interview Followup}
        Based on the results, the earlier pivot hypothesis may need to be pivoted again, after which features may be added/removed/amended.
        Exit criteria for this series of interviews includes:
        \begin{itemize}
          \item Can identify demographics of early adopters
          \item Can identify minimum features needed to solve problem
          \item MVP is significant improvement over existing solutions
        \end{itemize}

    \subsection{MVP Advice}
      Before an MVP is built, a UVP should be determined that provides significant value. The MVP should deliver on the UVP, and focus on
      addressing the customers' number one problem. The MVP should not focus at first on optimizing the solution, but rather on accelerating the
      learning process to facilitate continual improvement.

  \newpage

  \section{Requirements Elicitation}
    Requirements elicitation is the process of collecting requirements for a system. These requirements can be gathered from many types of sources,
    including stakeholders, existing documentation, similar or previous systems, and the environment of a system. Various elicitation techniques
    can be applied, including stakeholder analysis, domain analysis, brainstorming, and pilot experimentation.

    \subsection{Artifact-based Elicitation}
      The key idea behind artifact-based elicitation is to gather requirements from existing artifacts (e.g. documentation, existing systems)
      instead of relying on input from stakeholders. Elicitation techniques that are considered artifact-based include
      document studies, analyzing similar companies, norm studies, domain analysis, and requirements taxonomy.

      \subsubsection{Documents}
        Classes of documents that can be used for analysis include:
        \begin{itemize}
          \item \textbf{System documentation:} Can include design documents, bug reports, change requests, user manuals, work procedures, usage statistics,
          marketing data, and performance figures.
          \item \textbf{Environment documentation:} Can include organizational charts, business plans, policy manuals, financial reports, meeting overviews.
          \item \textbf{Domain analysis:} Can include textbooks, surveys, and standards and regulations documentations.
        \end{itemize}

      \subsubsection{Norms}
        Requirements can be gathered by forming a comparison to a different existing system (i.e. statements of the form ``Build a better X'').

      \subsubsection{Requirements Taxonomies}
        Requirements taxonomies are requirements classifications that can act as a list of requirements to be elicited. A sample taxonomy for information
        systems is an acronym known as PIECES (Performance, Information and data, Economy, Control, Efficiency, and Services). Taxonomies can be classified
        as being domain-specific (e.g. PIECES is for information systems) or domain-independent.

    \subsection{Stakeholder-based Elicitation}
      The key idea behind stakeholder-based elicitation is to gather detailed requirements information specific to particular problems or stakeholders.
      Elicitation techniques considered to be artifact-based include stakeholder analysis, questionnaires, interviews, observations, task demos, and personas.

      \subsubsection{Interviews}
        Interviews can be useful for gathering information specific to particular stakeholders, such as their specific problems or potential areas of conflict.
        To gather more information, it helps to ask open questions and allowing the stakeholder sufficient time to formulate a response. Examples of open questions
        include ``Why would you use this product?'', or ``What problems do you expect this product to solve for you?''. Interviews in groups can help in sharing more
        ideas, taking the spotlight off specific individuals, and pre-emptively identifying conflicts among stakeholders. Common mistakes during interviews include
        not interviewing the right people, asking directed questions early on, letting one person dominate a group discussion, or allowing the interview results to
        over-specify requirements.

      \subsubsection{Questionnaires}
        Questionnaires can be useful in gathering insights from a wide group of people, and can consist of open question (to gather suggestions) or closed questions
        (to gather opinions). A major limitation of questionnaires is that questions need to be fairly concrete, so although gathering large amounts of data can be
        effective, new insights are hard to obtain.

      \subsubsection{Ethnographic Analysis}
        Ethnographic analysis is a study of user behavior through observation, and can be useful in determining the human/social factors in a system that
        may be hard to gather from interviews alone. Ethnographic analysis can be useful in identifying the critical features of a system, though tends to focus on
        existing rather than new solutions.

      \subsubsection{Apprenticeship}
        An apprentice can gather requirements by spending time with an expert in some field. Information can be gathered through observation, asking questions, and
        performing some tasks under the expert's supervision.

      \subsubsection{Personas}
        Personas have been previously described; they can be useful if it is not feasible to interview actual users.

    \subsection{Model-based Elicitation}
      The key idea behind model-based elicitation is to express requirements languages useful for a particular purpose, which can help raise new insights and concerns.
      Elicitation techniques considered to be model-based include analysis patterns, mockups and prototyping, and pilot experimentation.

      \subsubsection{Requirements Models}
        A model is a simplified representation of a system that captures key details. Models can be used in requirements analysis to guide elicitation, help uncover
        problems, and provide a measure of progress. Re-expressing requirements through formal models can often reveal problems such as omissions and contradictions.

      \subsubsection{Mockups and Prototypes}
        Mockups and prototypes provide the essence of a proposed solution, and are often used to encourage further feedback and requirements elicitation from stakeholders.

    \subsection{Creativity-based Elicitation}
      The key idea behind creativity-based elicitation is to come up with new requirements that bring about a competitive advantage through innovation. Elicitation techniques
      considered to be creativity-based include systemic thinking, brainstorming, creativity workshops, and constraint relaxation.

      \subsubsection{Systemic Thinking}
        The goal of systemic thinking is to enlarge the scope of a problem under study from just a system to the outside world at large. The goal of systemic thinking is to
        gain an understanding of \textit{what} a topic of interest is, with attention paid to its observable behaviors and information flows rather than implementation
        details.

      \subsubsection{Brainstorming}
        Brainstorming is a group activity designed to generate a large number of new and creative ideas. Brainstorming sessions start with an idea generation phase, where
        participants are encourages to produce many new ideas, and judgement is suspended. Later, possibly with a new set of participants, the generated ideas are analyzed,
        and some can be expanded on even further.

      \subsubsection{Creativity Workshops}
        Creativity workshops are designed to be spaces for creating new ideas that go above and beyond original stakeholder requirements. Techniques for generating new ideas
        include brainstorming, constraint relaxation, and analogical reasoning.

  \newpage

  \section{Domain Models}
    A domain model is a model of the operating environment of some work under study. Domain models describe real-world entities and their interrelationships, and also capture
    information about the subject matter and environmental phenomena.

    \subsection{Unified Modeling Language (UML)}
      UML is a general-purpose modeling language for software systems. UML provides specifications for various types of structural diagrams (e.g. class diagrams, object diagrams)
      and behavioral diagrams (e.g. use case diagrams, activity diagrams, state machine diagrams).
      
      UML class diagrams are a good choice for representing domain models. When forming a UML class diagram based on requirements, it is typically best to leave out details;
      information based on requirements includes class names, key attribute names and association/roles names, while most other information is based on design.

    \subsection{Conceptual Classes}
      Conceptual classes provide a high-level overview of what a class does. Conceptual class category examples include business transactions (e.g FlightReservation), events
      (e.g. FlightDeparture) and descriptions of things (e.g. FlightDescription).

    \subsection{Finding Domain Entities}
      The main ways of finding domain entities include:
      \begin{itemize}
        \item \textbf{Refining existing domain models.} Either refining models for previous systems or general domain models.
        \item \textbf{Using a conceptual class list.} Can be generated by brainstorming what kinds of entities and entity classes are relevant to a system.
        \item \textbf{Identifying noun phrases.} Nouns in system descriptions often correspond to entities.
      \end{itemize}

    \subsection{Attributes}
      An attribute is a sub-part of an object describing the characteristics or properties of object instances. When forming class diagrams based on requirements, attributes can
      initially be modeled as just a name, with implementation details added later.

    \subsection{Associations}
      Associations represent relevant relationships between multiple conceptual classes. Physical (e.g. ``partof'') relationships are typically good candidates, while transient
      (e.g. ``communicates with'') relationships tend to be weaker. Where appropriate, associations can be named, typically with short verbs.

      \subsubsection{Roles and Multiplicities}
        A role is one end of a relationship, describing how an entity is viewed within the context of the relationship. Roles can also state multiplicities of association.

      \subsubsection{Association Classes}
        Should an association contain attributes of its own, it can be represented with an association class. The state of an association class should only be known by the instances
        of classes forming the relationship, and each of these objects should have at most one instance of the association class.

      \subsubsection{Association Qualifiers}
        Association qualifiers are an association attribute that can be used at one end of an association to distinguish among a set of objects at the other end of the association.
        An example is a filename serving as an association attribute for a set of files stored in a directory.

    \subsection{Composition/Aggregation}
      Composition is a stronger type of association than aggregation. Composition implies that an object cannot exist without its container object (i.e. there is a strong relation to
      at most one container), while aggregated objects may be weakly related to several containers.

    \subsection{Inheritance/Generalization}
      Inheritance is useful for representing ``is a kind of'' relationships (e.g. an Engineer is a kind of Employee). Properties such as attributes and association of parents can be
      inherited by children, which can implement abstract features, add new functionality, or override existing functionality. Non-leaf nodes may be abstract classes, which are
      indicated by italicized names.

    \subsection{Common Modeling Conundrums}

      \subsubsection{Tightly Coupled Classes}
        It may be tempting to combine classes with multiple one-to-one composition associations into a single class. However, if the class associations are dynamic, the classes should
        be kept distinct.

      \subsubsection{Similar but Distinct Classes}
        Multiple distinct concepts should not be mixed in a single class. This is particularly important when the concepts have similar names, since this can make them tempting to
        combine but also produces a confusing model.

      \subsubsection{Representing Object Identity}
        Objects should have an identity such that they can be distinguished from other objects with the same values. As such, it is typically a poor idea to base an object's identity
        on its properties (e.g. identify a house on a street by its street name).

      \subsubsection{Temporal Objects}
        In some situations, it is appropriate for a model to store a history of values for an object rather than just the current object.

      \subsubsection{Class-Scope Attributes}
        Class-scope attributes have a changeable value that is shared by all object instances of a class. Class-scope attributes can lead to trouble if different instances require
        that a different value be stored.

  \newpage

  \section{Prototyping}
    A prototype is a partial implementation designed to help stakeholders learn more about a problem or its solution.

    \subsection{Prototyping Categories}
      Prototypes can be divided into different categories, including:
      \begin{itemize}
        \item \textbf{Presentation prototypes}, which are used as a proof of concept to explain certain features/designs and then thrown away.
        \item \textbf{Exploratory prototypes}, which are used to learn more about the problem (e.g. elicit needs, clarify goals), and are also thrown away.
        \item \textbf{Experimental/Breadboard prototypes}, which are used to explore technical feasibility, typically with little to no user/customer involvement.
        \item \textbf{Evolutionary/Operational prototypes}, which is an early deliverable in a continuous development process that gets improved on later.
      \end{itemize}

    \subsection{Prototyping Methodologies}

      \subsection{Throwaway Prototyping}
        Throwaway prototypes are used to learn more about a problem, after which they are discarded and not used in a final product. The development of these systems is designed to be
        done rapidly, with a horizontal strategy often applied that only builds up a single layer at a time (e.g. only build UI for UI-related experimentation). Throwaway prototyping can
        be useful for gathering information early on (low risk). However, it may result in a lack of formal documentation, unrealistic customer expectations, and in some situations with
        major time constraints can end up getting developed into a final product (typically leads to poor design).

      \subsection{Evolutionary Prototyping}
        Evolutionary prototyping involves learning about a solution to a problem. Emphasis is placed on the ``risky'' parts of a solution first and the system is developed incrementally,
        with a vertical strategy that builds up all layers feature-by-feature typically preferred. Evolutionary prototypes tend to be good at evolving to requirements changes, and can be
        reverted to their previous increment should some change introduce major problems. However, evolutionary prototypes run the risk of poor early architectural choices, poorly
        structured systems, and often lack high-level direction and control.

      \subsection{Sketching and Wireframing}
        Sketches of a UI focus on content, and include the scope of what should be included on a display and how it should be organized. Wireframes are a visual representation of a UI
        that focus on content hierarchy and flow rather than presentation details (e.g. color, fonts, images, etc.). Sketching and wireframing both allow for the rapid generation of
        UI designs, which can be iterated on and refined further.

  \newpage

  \section{Quality Requirements}
    Functional requirements describe what a system is supposed to do (e.g. what services are provided, I/O behavior). Quality requirements describe some
    additional constraints for the system.

    Common examples of quality requirements include:
    \begin{itemize}
      \item \textbf{Performance} (e.g. execution speed, response time, throughput)
      \item \textbf{Reliability} (e.g. fault tolerance, mean time to failure (MTTF))
      \item \textbf{Robustness} (e.g. tolerance to invalid inputs, performance under stress)
      \item \textbf{Adaptability} (e.g. ease of adding new functionality, reusability in other environments)
      \item \textbf{Security} (e.g. controlled access to data, protection against theft)
      \item \textbf{Usability} (e.g. ease of learning, user productivity)
      \item \textbf{Scalability} (performance as workload increases in terms of data size, number of users, etc.)
      \item \textbf{Efficiency} (with respect to utilization of resources)
      \item \textbf{Accuracy/Precision} (e.g. precision of computations, tolerance for computation errors)
    \end{itemize}

    \subsection{``Motherhood'' Requirements}
      The term motherhood requirements refers to system requirements that are all-encompassing and do not differentiate well between different systems
      (e.g. ``reliable'', ``user-friendly'', ``maintainable''). Virtually every system must meet such requirements to some degree; what differentiates
      systems is the degree to which these attributes are required, and their relative importance.

    \subsection{Fit Criteria}
      Fit criteria quantify the extend to which a quality requirement must be met. Examples include:
      \begin{itemize}
        \item System must be down no more than 5 minutes a year.
        \item 90\% of users should be able to create an account within 2 minutes.
      \end{itemize}

      \subsubsection{Richer Fit Criteria}
        Richer fit criteria are a way of organizing fit criteria that includes a target metric, a minimum metric, and a high-achieving ``outstanding''
        metric. An example is that a system has a minimum response time of 1s, a target response time of 0.5s, and an outstanding response time
        of 0.1s.

    \subsection{Measurements}
      Effectively applying fit criteria can allow for measurement of quality requirements. However, not all fit criteria can be measured on a system
      prototype or new systems in general (e.g. criteria that concern large amounts of users or long amounts of time). In these cases, possible approaches
      to measurement include:
      \begin{itemize}
        \item Measuring attributes of prototype.
        \item Estimating quality attributes.
        \item Delivering a system and performing more accurate quality measurements later.
      \end{itemize}

      \subsubsection{Monte Carlo Techniques}
        Monte Carlo techniques are a class of computational techniques that apply random sampling to generate estimates. Such techniques can be used in
        estimating various aspects of a system's requirements. A sample application is deliberately planting $N$ bugs in a system, and then measuring how
        many are reported by developers or testers. The resulting bugs to reported bugs ratio can be used to give a rough estimate of the total number of
        unreported bugs in the system.

    \subsection{Prioritizing Quality Requirements}
      Different quality requirements can come into conflict with one another. Common areas of conflict include maintainability vs robustness, performance
      vs security, and performance vs reuse. Conflicts may also occur between quality and functional requirements (e.g. performance vs certain features).
      In such cases, requirements need to be prioritized.

  \section{Prioritizing Requirements}
    A system may have more requirements than can actually be implemented (e.g. too many requirements or requirements that conflict with one another).
    In such cases, requirements must be balanced with a project's limited resources in mind. This may be an issue of determining what features to add
    to an MVP or to a periodic release.

    \subsection{Prioritizing Criteria}
      A requirement's value is its potential contribution to customer satisfaction. Requirements can be prioritized by their value to cost ratios.

    \subsection{Grouping Requirements}
      A common prioritization technique is grouping requirements into 3-4 groups based on their urgency. An example of a set of groups may be
      ``Critical'', ``Standard'', and ``Optional''.

    \subsection{Ranking Requirements}
      It is possible to stack rank all requirements, though this gives little info on the relative differences between ranked requirements. This motivates
      the development of different ranking techniques.

      \subsubsection{100-Dollar Test}
        In this ranking system, stakeholders are given 100 ``dollars'' (i.e. points) to distribute among a project's requirements.

      \subsubsection{Kano Model}
        Kano models serve to analyze requirements based on customer perception. Kano charts have lines for features over two axis, one for customer
        satisfaction and one for execution. The shape of the lines can provide information on the type of feature, with the main types being:
        \begin{itemize}
          \item \textbf{Basic:} Poor execution and low satisfaction to good execution and neutral satisfaction indicates functionality taken for granted.
          \item \textbf{Performance:} Poor execution and low satisfaction to good execution and high satisfaction indicates a core requirement
            the customer expects.
          \item \textbf{Excitement:} Poor execution and neutral satisfaction to good execution and high satisfaction indicates useful functionality
            that is useful but not expected.
          \item \textbf{Indifferent:} Poor execution and neutral satisfaction to good execution and neutral satisfaction indicates a requirement the
            customer does not care about.
        \end{itemize}

        Kano surveys can be run to collect data to construct Kano models. The purpose of such surveys is to gauge customer reaction if a particular feature is
        included/excluded from a system. Generally speaking, the importance of features is Basic $>$ Performance $>$ Excitement $>$ Indifferent.

      \subsubsection{Analytical Hierarchy Process (AHP)}
        AHP is a requirement prioritization technique based on stakeholders' pairwise comparisons of requirements.
        These comparisons are used to produce a relative ranking of all requirements. This technique is based on that absolute values of requirements
        are hard to judge, and small comparisons are usually easier to manage. AHP analysis consists of the following steps:

        \begin{enumerate}
          \item
            Form a square matrix that stores a score between all pairs of requirements. If one comparison of requirements $R1$ and $R2$ is assigned a score of
            $A$, then the reciprocal comparison $R2$ and $R1$ is assigned a score of $\frac{1}{a}$.
            \begin{center}
              \begin{tabular}{ |c|c|c|c|c| } 
                \hline
                     & Req1 & Req2 & Req3 & Req4 \\ 
                \hline
                Req1 & $1$ & $\frac{1}{3}$ & $2$ & $4$ \\ 
                \hline
                Req2 & $3$ & $1$ & $5$ & $3$ \\ 
                \hline
                Req3 & $\frac{1}{2}$ & $\frac{1}{5}$ & $1$ & $\frac{1}{3}$ \\ 
                \hline
                Req4 & $\frac{1}{4}$ & $\frac{1}{3}$ & $3$ & $1$ \\ 
                \hline
              \end{tabular}
            \end{center}

          \item Normalize the columns of the matrix.
            \begin{center}
              \begin{tabular}{ |c|c|c|c|c| } 
                \hline
                     & Req1 & Req2 & Req3 & Req4 \\ 
                \hline
                Req1 & $0.21$ & $0.18$ & $0.18$ & $0.48$ \\ 
                \hline
                Req2 & $0.63$ & $0.54$ & $0.45$ & $0.36$ \\ 
                \hline
                Req3 & $0.11$ & $0.11$ & $0.09$ & $0.04$ \\ 
                \hline
                Req4 & $0.05$ & $0.18$ & $0.27$ & $0.12$ \\ 
                \hline
              \end{tabular}
            \end{center}

          \item Sum up reach row.
            \begin{center}
              \begin{tabular}{ |c| } 
                \hline
                Sum \\ 
                \hline
                $1.05$ \\
                \hline
                $1.98$ \\
                \hline
                $0.34$ \\
                \hline
                $0.62$ \\
                \hline
              \end{tabular}
            \end{center}

          \item Report the normalized, relative values of each requirement.
            \begin{center}
              \begin{tabular}{ |c| } 
                \hline
                Values \\
                \hline
                $26\%$ \\
                \hline
                $50\%$ \\
                \hline
                $9\%$ \\
                \hline
                $16\%$ \\
                \hline
              \end{tabular}
            \end{center}
        \end{enumerate}

        To check for consistency, the following steps can be applied:
          \begin{enumerate}
            \item Multiply the comparison matrix by the priority vector. Using the above matrix and vector, this should yield:
            $$
              \begin{bmatrix}
                1.22 \\
                2.18 \\
                0.37 \\
                0.64 \\
              \end{bmatrix}
            $$

            \item Divide each element by the corresponding element in the priority matrix.
            $$
              \begin{bmatrix}
                4.66 \\
                4.40 \\
                4.29 \\
                4.13 \\
              \end{bmatrix}
            $$

            \item Compute the principle eigenvalue.
            $$
              \frac{4.66 + 4.40 + 4.29 + 4.13}{4} = 4.37
            $$

            \item Calculate the consistency index.
            $$
              CI = \frac{4.37 - n}{n - 1} = \frac{4.37 - 4}{4 - 1} = 0.12
            $$

            \item Compare against consistency index of random matrix (this value can be found in a lookup table). Ideally, this consistency index should
              be below $0.10$.
            $$
              CR = \frac{0.12}{0.90} = 0.14
            $$
          \end{enumerate}

    \subsection{Challenges}
      Common challenges faced when prioritizing requirements include:
      \begin{itemize}
        \item Many requirements deemed essential
        \item Large number of requirements to prioritize
        \item Conflicting priorities
        \item Changing priorities
        \item Effective collaboration between developers and stakeholders
        \item Subjective prioritization
      \end{itemize}

    \subsection{Benefits}
      Benefits commonly gained from requirements prioritization include:
      \begin{itemize}
        \item Focusing on important requirements first, which improves customer satisfaction.
        \item Determining how to allocate limited project resources.
        \item Encouraging stakeholders to have a broader view of project requirements (i.e. consider other stakeholder requirements, not just their own).
      \end{itemize}

\end{document}

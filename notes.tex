\documentclass[12pt,titlepage]{article}
\usepackage[margin=1in]{geometry}
\usepackage{amsmath}
\usepackage{parskip}
\usepackage{amssymb}
\usepackage{wasysym}

\let\stdsection\section
\renewcommand\section{\clearpage\stdsection}

\usepackage{hyperref}
\hypersetup{
  linktoc=all
}

\begin{document}
  \begin{titlepage}
    \vspace*{\fill}
    \centering

    \textbf{\Huge SE 463 Course Notes} \\ [0.4em]
    \textbf{\Large Software Requirements Specification and Analysis} \\ [1em]
    \textbf{\Large Michael Socha} \\ [1em]
    \textbf{\large 4A Software Engineering} \\
    \textbf{\large University of Waterloo} \\
    \textbf{\large Spring 2018} \\
    \vspace*{\fill}
  \end{titlepage}

  \newpage 

  \pagenumbering{roman}

  \tableofcontents

  \newpage

  \pagenumbering{arabic}

  \section{Course Overview}
    Many software project failures are not due to technical reasons, but rather due to poor project specifications. This course
    focuses on requirement-related topics including:
    \begin{itemize}
      \item Different types of requirements
      \item Learning about stakeholder needs
      \item Analyzing and refining preliminary requirements
      \item Expressing requirements in various representations
      \item Managing requirement changes
    \end{itemize}

  \section{Business Model}
    \subsection{Traditional Product Model}
      A traditional ``waterfall'' style of development relies heavily on the initial implementation meeting customer needs. This
      approach often leads to requirements-related problems, since the business and development team might not understand the
      customer needs or the customer needs might change, and a waterfall model offers little room to refine these requirements.

    \subsection{Lean Product Development Model}
      A lean product development model focuses on first determining whether a project addresses an important problem (e.g. problem
      fit), and whether the project provides a solution people want (market fit). Only after these are established is a product built,
      which is usually nimble at first and then scales up.

    \subsection{Lean Canvas}
      A lean canvas is a template to help determine the initial requirements for a project, especially one in the new product or
      consulting space. The sections of a lean canvas are described below:

      \subsubsection{Customer Segments}
        This is a list of potential customers and users. It helps to have granular segments, and focus should be placed on segments likely
        to become early adopters.

      \subsubsection{Problem Segments}
        This is a list of a few top problems that each customer segment wants solved.

      \subsubsection{Unique Value Proposition}
        This is a reason why the project is unique and valuable. The focus should also be on early adopters.

      \subsubsection{Solution}
        This is a list of solutions early adopters already apply to solve this problem. From this list, some key capabilities and features
        of the software project can be determined.

      \subsubsection{Channels}
        This is a list of methods to reach the project's target customers. This is important to consider early, since these customers
        are not just useful as end users, but also as subjects of testing and experiments during development.

      \subsubsection{Revenue Streams and Costs}
        Revenue and costs should be considered early in a project. If the project is going to operate on a subscription model, it is
        a good idea to charge something from the start (with the exception of a free trial period). ``Freemium'' business models, in
        which core services are free, tend to have low conversion rates to paying features.

      \subsubsection{Key Metrics}
        This is a list of metrics to be used for measuring success.

      \subsubsection{Unfair Advantage}
        This refers to some sort of competitive advantage that is hard to replicate. Examples include an existing reputation or customer
        base, proprietary data, or patented work.

  \section{Hypothesis Testing}
    The purpose of hypothesis testing is to validate or disprove guesses in a project's business model. Hypothesis testing is generally
    conducted by performing pass/fail experiments through market research or customer interviews. Hypothesis being disproved can lead
    to learning, after which the hypothesis can be pivoted based on new understanding.

    \subsection{Hypothesis}
      A hypothesis is a tentative guess about a phenomenon of interest that is testable and falsifiable. The phenomena of interest
      (e.g. characteristics of customer problem) are considered to be dependent variables, while independent variables affect the
      phenomenon of interest. A good hypothesis must be testable (i.e. possible to observe effects of independent variables on
      dependent variables) and falsifiable.

      \subsubsection{Falsifiable Hypothesis}
        A falsifiable hypothesis is a statement that can easily be proven wrong. Specific and testable statements are more falsifiable
        than vague ones. Falsifiable hypothesis often have somewhat of a universally quantification aspect (e.g. all, most, etc), rather
        than merely existential quantification.

    \subsection{Testing Risks}
      Uncertainty simply means that there are multiple possibilities. Risk tends to involve uncertainty, with some of the possibilities
      leading to failure. The three largest risks to a project are:
      \begin{itemize}
        \item \textbf{Customer Risk} e.g. Is there a viable customer segment, and what are their risks?
        \item \textbf{Product Risk} e.g. How do customers rank the top three problems?
        \item \textbf{Market Risk} e.g. How do customers solve these problems today?
      \end{itemize}

    \subsection{Problem Interview}
      Interviews to test hypotheses generally follow the plan below:
      \begin{itemize}
        \item Welcome
        \item Collect demographics (i.e. test customer segment)
        \item Tell a story (i.e. set a problem context)
        \item Problem ranking
        \item Explore customer's worldview
        \item Wrapping up (i.e. hook and ask)
        \item Document results
      \end{itemize}

    \subsection{Processing Results}
      It is important to home in on early adopters. As more information is gathered, it may help to refine the problem or pivot the hypothesis.
      It helps to continue gathering results until they are fairly consistent. Good indications that enough testing has been done are that
      the demographics of an early adopter can be identified, there is a must-have (i.e. critical problem to work on first) problem, and there is
      an understanding of how customers currently solve this problem.

  \section{Stakeholders}
    A stakeholder is considered to be anyone who has a stake in a project's ultimate success or failure. Stakeholders an include the development
    team, people in the operational work area, the containing business, and forces from the outside world.

    \subsection{Owners/Clients/Champions}
      The owner/client is the group paying for the software to be developed. They are usually considered to be the ultimate/champion stakeholder,
      since they often have the final say in a project. Examples include a client in a consultancy project, or the company that developers are working
      for in an internal project.

    \subsection{Customers}
      A customer buys a project after its completion. The customer may be the same person as the owner or user.

    \subsection{Users}
      Users tends to be experts on the work the system is performing, and experts on any existing systems or competing products. Users typically
      have specific needs a product should satisfy.

      \subsubsection{User Classes}
        To meet various user needs, it helps to categorize users by their differences, including:
        \begin{itemize}
          \item Access privilege and security levels
          \item Tasks regularly performed
          \item Features used
          \item Frequency of use
          \item Application domain expertise, technical expertise
          \item Platform of use
          \item Preferred language
          \item Disfavored users, which are users who should not have access for security, legal or safety reasons (e.g. kids on some social media platforms)
        \end{itemize}

    \subsection{Personas}
      Personas are resemblances of actual users that can be constructed when real users are hard to interview (e.g. not numerous, too numerous). Personas
      should imitate the key details of important user classes. Enough details should be provided to make the persona seem realistic. Effectively built
      personas can:
      \begin{itemize}
        \item Guard against building a product just from the developer's perspective
        \item Guard against adapting to ``elastic'' users, and instead focus on keeners and early adopters
      \end{itemize}

    \subsection{Domain Expert}
      Domain experts understand the problem domain very well, are familiar with typical users, their expectations, and potential deployment environments.
      Note that domain experts need not know much about software engineering.

    \subsection{Software Engineer}
      A software engineering is an expert on the project's development technologies. These stakeholders can represent the development teams they run, and
      are responsible for overseeing the progress of the technical and some economic aspects of the project. Software engineering can also educate customers
      how available technology can affect the requested functionality.

    \subsection{Other Stakeholders}
      Other potential stakeholders include:
      \begin{itemize}
        \item \textbf{Inspectors:} Experts on government and safety regulations
        \item \textbf{Market researchers:} Can serve as proxy for customer interviews
        \item \textbf{Lawyers:} Familiar with legal requirements and licensing
        \item \textbf{Experts on adjacent systems:} Can explain how adjacent systems can affect the project
        \item \textbf{Negative stakeholders:} Stakeholders that want a project to fail
      \end{itemize}

  \section{User Requirements}

    \subsection{Use Cases}
      A use case represents some sort of end-to-end functionality in a system, capturing both its triggering event and the complete system response.
      Time-triggered use cases feature time as their triggering event. Well-defined use cases should not overlap much with one another.

      \subsection{Actors}
        An actor is an entity that interacts with the described system, which may include users or other systems. A supporting actor provides some service to the
        described system.

        \subsubsection{Actor Generalization}
          Actors often share common use cases with one another. In these cases, actor generalization can be applied, which factors out common behavior as an
          abstract actor.

      \subsection{Modifying Use Cases}
        \begin{itemize}
          \item $<<$include$>>$ is used to add a sub use case that is used in multiple other use cases
          \item $<<$extend$>>$ is used to extend or replace the end of an existing use case
        \end{itemize}
        Note that well-described systems tend to use these modifiers sparingly.

      \subsection{Use-Case Descriptions}
        Textual formats known as use-case descriptions are commonly used to represent use-cases. These descriptions vary in the amount of detail provided for
        each use case.

      \subsection{User Stories}
        User stories are an alternative to use-case descriptions for describing a system. Instead of being told from the system's perspective, user stories
        provide a description of something a user wants to be able to do (i.e. user requirements). The parts of a successfully managed user story are:
        \begin{itemize}
          \item \textbf{Card:} The initial description, often phrased as ``As a $<$role$>$, I want $<$something$>$ so that $<$benefit$>$''
          \item \textbf{Conversation:} Discussion with product owner to determine requirement details
          \item \textbf{Confirmation:} Criteria for determining whether an implementation meets requirements (conditions of satisfaction are described
          from the system's perspective)
        \end{itemize}

        \subsubsection{Benefits of User Stories}
          The benefits of user stories include:
          \begin{itemize}
            \item Easy for stakeholders to understand
            \item User-focused style encourages discussion more than ordinary written documentation
            \item Encouraging iterative development when stories are sized accordingly
          \end{itemize}

      \subsection{Changing Requirements}
        System requirements often change during the development process. Below are key topics to consider when managing requirement changes.

        \subsubsection{Requirements Baseline}
          A requirements baseline is a set of formally reviewed and agreed core requirements for a system. Major requirement changes should pass
          through this review process, and it may be helpful to limit the rate of change to these requirements.

        \subsubsection{Unique Value Proposition (UVP)}
          New requirements should not weaken a project's UVP.

        \subsubsection{Project Scope}
          When project scope is not managed well, there is a tendency for ``scope creep'' to occur. Scope creep can be mitigated by keeping a
          prioritized list of requirements, and only adding a few major ones to each release.

  \section{Workflow Models}
    A use case can be decomposed into an ordered sequence of tasks known as a workflow. Each task in a workflow specifies the data it requires
    and the data it produces.

    \subsection{Scenarios}
      A scenario is one full execution path through a use case, listing only observable actions between a system and external actors. A use case can
      be considered to be a collection of success and failure scenarios initiated by an external actor to achieve a particular goal. Below is an example
      scenario for a banking system:
      \begin{enumerate}
        \item User requests to withdraw funds, specifies amount.
        \item Bank authenticates user.
        \item Bank checks account has sufficient funds.
        \item Bank dispenses cash and receipt.
        \item Bank records the transaction.
        \item User takes case and receipt, leaves.
      \end{enumerate}

      A general template for a scenario includes:
      \begin{itemize}
        \item \textbf{Business event name}
        \item \textbf{Business use case name/reference}
        \item \textbf{Trigger}
        \item \textbf{Preconditions}
        \item \textbf{Interested stakeholders}
        \item \textbf{Active stakeholders}
        \item \textbf{Normal case steps}
        \item \textbf{Alternatives} - Sub use cases that capture the main goal of this use case through a different sequence of actions
        \item \textbf{Exceptions} - Sub use cases that capture an unwanted deviation
        \item \textbf{Postconditions}
      \end{itemize}

      \subsubsection{More Complex Actions}
        Scenario actions can include more complex control flow, such as branching and looping. However, this should be used sparingly, and is
        often a good indicator that the scenario is becoming too detailed or all-encompassing.

    \subsection{Workflow Diagrams}
      \subsubsection{Activity Diagram}
        Activity diagrams are UML graphical representations of a system's flow control between activities and actions.

      \subsubsection{Dataflow Diagram (DFD)}
        DFDs are graphical representations of the functional decomposition of an information system. Each step in a described workflow
        states what information it requires along with its source, and what information is produced along with its destination.

  \section{MVP (Minimum Viable Product) Hypothesis Testing}
    It is important to run experiments to assess the risks of a solution. Areas of risk to assess include customer risk (e.g. who the
    early adopters are, how they will be reached), and product risk (e.g. whether the solution and UVP align with the customers' main
    problem, and what the minimum set of features required to launch is).

    \subsection{Solution Interview}
      \subsubsection{Interview Flow}
        An interview designed to test the risks of a MVP solution can follow the general flow below:
        \begin{enumerate}
          \item \textbf{Welcome:} Set the stage for how the interview works.
          \item \textbf{Collect demographics:} Try to determine how the interviewee approaches the problem at hand (e.g. for a job search platform,
          learn about their job search habits).
          \item \textbf{Tell a story:} Illustrate the top problems the MVP is trying to solve through a brief story.
          \item \textbf{Demo (Test Solution):} For each problem, go through the workflow and determine whether it addresses the interviewee's main
          problems. This may appear to be a pitch, but its goal is learning more so than marketing. Attention should be paid to the interviewee's
          attitude and reactions. Unexpected reactions provide great learning opportunities and should be examined.
          \item \textbf{Wrapping up:} Ask for permission to follow up, as well as for referrals for other prospective interviewees.
        \end{enumerate}

      \subsubsection{Interview Followup}
        Based on the results, the earlier pivot hypothesis may need to be pivoted again, after which features may be added/removed/amended.
        Exit criteria for this series of interviews includes:
        \begin{itemize}
          \item Can identify demographics of early adopters
          \item Can identify minimum features needed to solve problem
          \item MVP is significant improvement over existing solutions
        \end{itemize}

    \subsection{MVP Advice}
      Before an MVP is built, a UVP should be determined that provides significant value. The MVP should deliver on the UVP, and focus on
      addressing the customers' number one problem. The MVP should not focus at first on optimizing the solution, but rather on accelerating the
      learning process to facilitate continual improvement.

  \section{Requirements Elicitation}
    Requirements elicitation is the process of collecting requirements for a system. These requirements can be gathered from many types of sources,
    including stakeholders, existing documentation, similar or previous systems, and the environment of a system.

    \subsection{Artifact-based Elicitation}
      The key idea behind artifact-based elicitation is to gather requirements from existing artifacts (e.g. documentation, existing systems)
      instead of relying on input from stakeholders. Elicitation techniques that are considered artifact-based include
      document studies, analyzing similar companies, norm studies, domain analysis, and requirements taxonomy.

      \subsubsection{Documents}
        Classes of documents that can be used for analysis include:
        \begin{itemize}
          \item \textbf{System documentation:} Can include design documents, bug reports, change requests, user manuals, work procedures, usage statistics,
          marketing data, and performance figures.
          \item \textbf{Environment documentation:} Can include organizational charts, business plans, policy manuals, financial reports, meeting overviews.
          \item \textbf{Domain analysis:} Can include textbooks, surveys, and standards and regulations documentations.
        \end{itemize}

      \subsubsection{Norms}
        Requirements can be gathered by forming a comparison to a different existing system (i.e. statements of the form ``Build a better X'').

      \subsubsection{Requirements Taxonomies}
        Requirements taxonomies are requirements classifications that can act as a list of requirements to be elicited. A sample taxonomy for information
        systems is an acronym known as PIECES (Performance, Information and data, Economy, Control, Efficiency, and Services). Taxonomies can be classified
        as being domain-specific (e.g. PIECES is for information systems) or domain-independent.

    \subsection{Stakeholder-based Elicitation}
      The key idea behind stakeholder-based elicitation is to gather detailed requirements information specific to particular problems or stakeholders.
      Elicitation techniques considered to be stakeholder-based include stakeholder analysis, questionnaires, interviews, observations, task demos, and personas.

      \subsubsection{Interviews}
        Interviews can be useful for gathering information specific to particular stakeholders, such as their specific problems or potential areas of conflict.
        To gather more information, it helps to ask open questions and allow the stakeholder sufficient time to formulate a response. Examples of open questions
        include ``Why would you use this product?'', or ``What problems do you expect this product to solve for you?''.

        Interviews in groups can help in sharing more ideas, taking the spotlight off specific individuals, and pre-emptively identifying conflicts among stakeholders.
        Common mistakes during interviews include not interviewing the right people, asking directed questions early on, letting one person dominate a group discussion,
        or allowing the interview results to over-specify requirements.

      \subsubsection{Questionnaires}
        Questionnaires can be useful in gathering insights from a wide group of people, and can consist of open question (to gather suggestions) or closed questions
        (to gather opinions). A major limitation of questionnaires is that questions need to be fairly concrete, so although gathering large amounts of data can be
        effective, new insights are hard to obtain.

      \subsubsection{Ethnographic Analysis}
        Ethnographic analysis is a study of user behavior through observation, and can be useful in determining the human/social factors in a system that
        may be hard to gather from interviews alone. Ethnographic analysis can be useful in identifying the critical features of a system, though tends to focus on
        existing rather than new solutions.

      \subsubsection{Apprenticeship}
        An apprentice can gather requirements by spending time with an expert in some field. Information can be gathered through observation, asking questions, and
        performing some tasks under the expert's supervision.

      \subsubsection{Personas}
        Personas have been previously described; they can be useful if it is not feasible to interview actual users.

    \subsection{Model-based Elicitation}
      The key idea behind model-based elicitation is to express requirements languages useful for a particular purpose, which can help raise new insights and concerns.
      Elicitation techniques considered to be model-based include analysis patterns, mockups and prototyping, and pilot experimentation.

      \subsubsection{Requirements Models}
        A model is a simplified representation of a system that captures key details. Models can be used in requirements analysis to guide elicitation, help uncover
        problems, and provide a measure of progress. Re-expressing requirements through formal models can often reveal problems such as omissions and contradictions.

      \subsubsection{Mockups and Prototypes}
        Mockups and prototypes provide the essence of a proposed solution, and are often used to encourage further feedback and requirements elicitation from stakeholders.

    \subsection{Creativity-based Elicitation}
      The key idea behind creativity-based elicitation is to come up with new requirements that bring about a competitive advantage through innovation. Elicitation techniques
      considered to be creativity-based include systemic thinking, brainstorming, creativity workshops, and constraint relaxation.

      \subsubsection{Systemic Thinking}
        The goal of systemic thinking is to enlarge the scope of a problem under study from just a system to the outside world at large. The goal of systemic thinking is to
        gain an understanding of \textit{what} a topic of interest is, with attention paid to its observable behaviors and information flows rather than implementation
        details.

      \subsubsection{Brainstorming}
        Brainstorming is a group activity designed to generate a large number of new and creative ideas. Brainstorming sessions start with an idea generation phase, where
        participants are encouraged to produce many new ideas, and judgement is suspended. Later, possibly with a new set of participants, the generated ideas are analyzed,
        and some can be expanded on even further.

      \subsubsection{Creativity Workshops}
        Creativity workshops are designed to be spaces for creating new ideas that go above and beyond original stakeholder requirements. Techniques for generating new ideas
        include brainstorming, constraint relaxation, and analogical reasoning.

  \section{Domain Models}
    A domain model is a model of the operating environment of some work under study. Domain models describe real-world entities and their interrelationships, and also capture
    information about the subject matter and environmental phenomena.

    \subsection{Unified Modeling Language (UML)}
      UML is a general-purpose modeling language for software systems. UML provides specifications for various types of structural diagrams (e.g. class diagrams, object diagrams)
      and behavioral diagrams (e.g. use case diagrams, activity diagrams, state machine diagrams).
      
      UML class diagrams are a good choice for representing domain models. When forming a UML class diagram based on requirements, it is typically best to leave out details;
      information based on requirements includes class names, key attribute names and association/roles names, while most other information is based on design.

    \subsection{Conceptual Classes}
      Conceptual classes provide a high-level overview of what a class does. Conceptual class category examples include business transactions (e.g. FlightReservation), events
      (e.g. FlightDeparture) and descriptions of things (e.g. FlightDescription).

    \subsection{Finding Domain Entities}
      The main ways of finding domain entities include:
      \begin{itemize}
        \item \textbf{Refining existing domain models.} Either refining models for previous systems or general domain models.
        \item \textbf{Using a conceptual class list.} Can be generated by brainstorming what kinds of entities and entity classes are relevant to a system.
        \item \textbf{Identifying noun phrases.} Nouns in system descriptions often correspond to entities.
      \end{itemize}

    \subsection{Attributes}
      An attribute is a sub-part of an object describing the characteristics or properties of object instances. When forming class diagrams based on requirements, attributes can
      initially be modeled as just a name, with implementation details added later.

    \subsection{Associations}
      Associations represent relevant relationships between multiple conceptual classes. Physical (e.g. ``part of'') relationships are typically good candidates, while transient
      (e.g. ``communicates with'') relationships tend to be weaker. Where appropriate, associations can be named, typically with short verbs.

      \subsubsection{Roles and Multiplicities}
        A role is one end of a relationship, describing how an entity is viewed within the context of the relationship. Roles can also state multiplicities of association.

      \subsubsection{Association Classes}
        Should an association contain attributes of its own, it can be represented with an association class. The state of an association class should only be known by the instances
        of classes forming the relationship, and each of these objects should have at most one instance of the association class.

      \subsubsection{Association Qualifiers}
        Association qualifiers are an association attribute that can be used at one end of an association to distinguish among a set of objects at the other end of the association.
        An example is a filename serving as an association attribute for a set of files stored in a directory.

    \subsection{Composition/Aggregation}
      Composition is a stronger type of association than aggregation. Composition implies that an object cannot exist without its container object (i.e. there is a strong relation to
      at most one container), while aggregated objects may be weakly related to several containers.

    \subsection{Inheritance/Generalization}
      Inheritance is useful for representing ``is a kind of'' relationships (e.g. an Engineer is a kind of Employee). Properties such as attributes and association of parents can be
      inherited by children, which can implement abstract features, add new functionality, or override existing functionality. Non-leaf nodes may be abstract classes, which are
      indicated by italicized names.

    \subsection{Common Modeling Conundrums}

      \subsubsection{Tightly Coupled Classes}
        It may be tempting to combine classes with multiple one-to-one composition associations into a single class. However, if the class associations are dynamic, the classes should
        be kept distinct.

      \subsubsection{Similar but Distinct Classes}
        Multiple distinct concepts should not be mixed in a single class. This is particularly important when the concepts have similar names, since this can make them tempting to
        combine but also produces a confusing model.

      \subsubsection{Representing Object Identity}
        Objects should have an identity such that they can be distinguished from other objects with the same values. As such, it is typically a poor idea to base an object's identity
        on its properties (e.g. identify a house on a street by its street name).

      \subsubsection{Temporal Objects}
        In some situations, it is appropriate for a model to store a history of values for an object rather than just the current value.

      \subsubsection{Class-Scope Attributes}
        Class-scope attributes have a changeable value that is shared by all object instances of a class. Class-scope attributes can lead to trouble if different instances require
        that a different value be stored.

  \section{Prototyping}
    A prototype is a partial implementation designed to help stakeholders learn more about a problem or its solution.

    \subsection{Prototyping Categories}
      Prototypes can be divided into different categories, including:
      \begin{itemize}
        \item \textbf{Presentation prototypes}, which are used as a proof of concept to explain certain features/designs and then thrown away.
        \item \textbf{Exploratory prototypes}, which are used to learn more about the problem (e.g. elicit needs, clarify goals), and are also thrown away.
        \item \textbf{Experimental/Breadboard prototypes}, which are used to explore technical feasibility, typically with little to no user/customer involvement.
        \item \textbf{Evolutionary/Operational prototypes}, which is an early deliverable in a continuous development process that gets improved on later.
      \end{itemize}

    \subsection{Prototyping Methodologies}

      \subsubsection{Throwaway Prototyping}
        Throwaway prototypes are used to learn more about a problem, after which they are discarded and not used in a final product. The development of these systems is designed to be
        done rapidly, with a horizontal strategy often applied that only builds up a single layer at a time (e.g. only build UI for UI-related experimentation). Throwaway prototyping can
        be useful for gathering information early on (low risk). However, it may result in a lack of formal documentation, unrealistic customer expectations, and in some situations with
        major time constraints can end up getting developed into a final product (which typically leads to poor design).

      \subsubsection{Evolutionary Prototyping}
        Evolutionary prototyping involves learning about a solution to a problem. Emphasis is placed on the ``risky'' parts of a solution first and the system is developed incrementally,
        typically with a vertical strategy that builds up all layers feature-by-feature. Evolutionary prototypes tend to be good at evolving to requirements changes, and can be
        reverted to their previous increment should some change introduce major problems. However, evolutionary prototypes run the risk of poor early architectural choices, poorly
        structured systems, and often lack high-level direction and control.

      \subsection{Sketching and Wireframing}
        Sketches of a UI focus on content, and include the scope of what should be included on a display and how it should be organized. Wireframes are a visual representation of a UI
        that focus on content hierarchy and flow rather than presentation details (e.g. color, fonts, images, etc.). Sketching and wireframing both allow for the rapid generation of
        UI designs, which can be iterated on and refined further.

  \section{Quality Requirements}
    Functional requirements describe what a system is supposed to do (e.g. what services are provided, I/O behavior). Quality requirements describe some
    additional constraints for the system.

    Common examples of quality requirements include:
    \begin{itemize}
      \item \textbf{Performance} (e.g. execution speed, response time, throughput)
      \item \textbf{Reliability} (e.g. fault tolerance, mean time to failure (MTTF))
      \item \textbf{Robustness} (e.g. tolerance to invalid inputs, performance under stress)
      \item \textbf{Adaptability} (e.g. ease of adding new functionality, reusability in other environments)
      \item \textbf{Security} (e.g. controlled access to data, protection against theft)
      \item \textbf{Usability} (e.g. ease of learning, user productivity)
      \item \textbf{Scalability} (performance as workload increases in terms of data size, number of users, etc.)
      \item \textbf{Efficiency} (with respect to utilization of resources)
      \item \textbf{Accuracy/Precision} (e.g. precision of computations, tolerance for computation errors)
    \end{itemize}

    \subsection{``Motherhood'' Requirements}
      The term motherhood requirements refers to system requirements that are all-encompassing and do not differentiate well between different systems
      (e.g. ``reliable'', ``user-friendly'', ``maintainable''). Virtually every system must meet such requirements to some degree; what differentiates
      systems is the degree to which these attributes are required, and their relative importance.

    \subsection{Fit Criteria}
      Fit criteria quantify the extent to which a quality requirement must be met. Examples include:
      \begin{itemize}
        \item System must be down no more than 5 minutes a year.
        \item 90\% of users should be able to create an account within 2 minutes.
      \end{itemize}

      \subsubsection{Richer Fit Criteria}
        Richer fit criteria are a way of organizing fit criteria that includes a target metric, a minimum metric, and a high-achieving ``outstanding''
        metric. An example is that a system has a minimum response time of 1s, a target response time of 0.5s, and an outstanding response time
        of 0.1s.

    \subsection{Measurements}
      Effectively applying fit criteria can allow for measurement of quality requirements. However, not all fit criteria can be measured on a system
      prototype or new systems in general (e.g. criteria that concern large amounts of users or long amounts of time). In these cases, possible approaches
      to measurement include:
      \begin{itemize}
        \item Measuring attributes of prototype.
        \item Estimating quality attributes.
        \item Delivering a system and performing more accurate quality measurements later.
      \end{itemize}

      \subsubsection{Monte Carlo Techniques}
        Monte Carlo techniques are a class of computational techniques that apply random sampling to generate estimates. Such techniques can be used in
        estimating various aspects of a system's requirements. A sample application is deliberately planting $N$ bugs in a system, and then measuring how
        many are reported by developers or testers. The resulting bugs to reported bugs ratio can be used to give a rough estimate of the total number of
        unreported bugs in the system.

    \subsection{Prioritizing Quality Requirements}
      Different quality requirements can come into conflict with one another. Common areas of conflict include maintainability vs robustness, performance
      vs security, and performance vs reuse. Conflicts may also occur between quality and functional requirements (e.g. performance vs certain features).
      In such cases, requirements need to be prioritized. This is expanded on further in the next section.

  \section{Prioritizing Requirements}
    A system may have more requirements than can actually be implemented (e.g. too many requirements or requirements that conflict with one another).
    In such cases, requirements must be balanced with a project's limited resources in mind. This may be an issue of determining what features to add
    to an MVP or to a periodic release.

    \subsection{Prioritizing Criteria}
      A requirement's value is its potential contribution to customer satisfaction. Requirements can be prioritized by their value to cost ratios.

    \subsection{Grouping Requirements}
      A common prioritization technique is grouping requirements into 3-4 groups based on their urgency. An example of a set of groups may be
      ``Critical'', ``Standard'', and ``Optional''.

    \subsection{Ranking Requirements}
      It is possible to stack rank all requirements, though this gives little info on the relative differences between ranked requirements. This motivates
      the development of different ranking techniques.

      \subsubsection{100-Dollar Test}
        In this ranking system, stakeholders are given 100 ``dollars'' (i.e. points) to distribute among a project's requirements.

      \subsubsection{Kano Model}
        Kano models serve to analyze requirements based on customer perception. Kano charts have lines for features over two axis, one for customer
        satisfaction and one for execution. The shape of the lines can provide information on the type of feature, with the main types being:
        \begin{itemize}
          \item \textbf{Basic:} Poor execution and low satisfaction to good execution and neutral satisfaction indicates functionality taken for granted.
          \item \textbf{Performance:} Poor execution and low satisfaction to good execution and high satisfaction indicates a core requirement
            the customer expects.
          \item \textbf{Excitement:} Poor execution and neutral satisfaction to good execution and high satisfaction indicates functionality
            that is useful but not expected.
          \item \textbf{Indifferent:} Poor execution and neutral satisfaction to good execution and neutral satisfaction indicates a requirement the
            customer does not care about.
        \end{itemize}

        Kano surveys can be run to collect data to construct Kano models. The purpose of such surveys is to gauge customer reaction if a particular feature is
        included/excluded from a system. Generally speaking, the importance of features is Basic $>$ Performance $>$ Excitement $>$ Indifferent.

      \subsubsection{Analytical Hierarchy Process (AHP)}
        AHP is a requirement prioritization technique based on stakeholders' pairwise comparisons of requirements. These comparisons are used to produce a relative
        ranking of all requirements. This technique is based on the idea that absolute values of requirements are hard to judge, and small comparisons are usually
        easier to manage. AHP analysis consists of the following steps:

        \begin{enumerate}
          \item
            Form a square matrix that stores a score between all pairs of requirements. If one comparison of requirements $R1$ and $R2$ is assigned a score of
            $A$, then the reciprocal comparison $R2$ and $R1$ is assigned a score of $\frac{1}{a}$. An example is below.
            \begin{center}
              \begin{tabular}{ |c|c|c|c|c| } 
                \hline
                     & Req1 & Req2 & Req3 & Req4 \\ 
                \hline
                Req1 & $1$ & $\frac{1}{3}$ & $2$ & $4$ \\ 
                \hline
                Req2 & $3$ & $1$ & $5$ & $3$ \\ 
                \hline
                Req3 & $\frac{1}{2}$ & $\frac{1}{5}$ & $1$ & $\frac{1}{3}$ \\ 
                \hline
                Req4 & $\frac{1}{4}$ & $\frac{1}{3}$ & $3$ & $1$ \\ 
                \hline
              \end{tabular}
            \end{center}

          \item Normalize the columns of the matrix.
            \begin{center}
              \begin{tabular}{ |c|c|c|c|c| } 
                \hline
                     & Req1 & Req2 & Req3 & Req4 \\ 
                \hline
                Req1 & $0.21$ & $0.18$ & $0.18$ & $0.48$ \\ 
                \hline
                Req2 & $0.63$ & $0.54$ & $0.45$ & $0.36$ \\ 
                \hline
                Req3 & $0.11$ & $0.11$ & $0.09$ & $0.04$ \\ 
                \hline
                Req4 & $0.05$ & $0.18$ & $0.27$ & $0.12$ \\ 
                \hline
              \end{tabular}
            \end{center}

          \item Sum up reach row.
            \begin{center}
              \begin{tabular}{ |c| } 
                \hline
                Sum \\ 
                \hline
                $1.05$ \\
                \hline
                $1.98$ \\
                \hline
                $0.34$ \\
                \hline
                $0.62$ \\
                \hline
              \end{tabular}
            \end{center}

          \item Report the normalized, relative values of each requirement.
            \begin{center}
              \begin{tabular}{ |c| } 
                \hline
                Values \\
                \hline
                $26\%$ \\
                \hline
                $50\%$ \\
                \hline
                $9\%$ \\
                \hline
                $16\%$ \\
                \hline
              \end{tabular}
            \end{center}
        \end{enumerate}

        To check for consistency, the following steps can be applied:
          \begin{enumerate}
            \item Multiply the comparison matrix by the priority vector. Using the above matrix and vector, this should yield:
            $$
              \begin{bmatrix}
                1.22 \\
                2.18 \\
                0.37 \\
                0.64 \\
              \end{bmatrix}
            $$

            \item Divide each element by the corresponding element in the priority matrix.
            $$
              \begin{bmatrix}
                4.66 \\
                4.40 \\
                4.29 \\
                4.13 \\
              \end{bmatrix}
            $$

            \item Compute the principle eigenvalue.
            $$
              \frac{4.66 + 4.40 + 4.29 + 4.13}{4} = 4.37
            $$

            \item Calculate the consistency index.
            $$
              CI = \frac{4.37 - n}{n - 1} = \frac{4.37 - 4}{4 - 1} = 0.12
            $$

            \item Compare against consistency index of random matrix (this value can be found in a lookup table). Ideally, this consistency index should
              be below $0.10$.
            $$
              CR = \frac{0.12}{0.90} = 0.14
            $$
          \end{enumerate}

    \subsection{Challenges}
      Common challenges faced when prioritizing requirements include:
      \begin{itemize}
        \item Many requirements deemed essential
        \item Large number of requirements to prioritize
        \item Conflicting priorities
        \item Changing priorities
        \item Effective collaboration between developers and stakeholders
        \item Subjective prioritization
      \end{itemize}

    \subsection{Benefits}
      Benefits commonly gained from requirements prioritization include:
      \begin{itemize}
        \item Focusing on important requirements first, which improves customer satisfaction.
        \item Determining how to allocate limited project resources.
        \item Encouraging stakeholders to have a broader view of project requirements (i.e. consider other stakeholder requirements, not just their own).
      \end{itemize}

  \section{Risks}
    A risk is an uncertain factor whose occurrence may result in some loss of satisfaction for some objective.

    \subsection{Risk Exposure}
      Risk exposure is a measure of the degree of risk, and is typically defined as:

      $$RE = Probability_{occurrence} \cdot Cost_{consequences}$$

      The higher the risk exposure, the more it makes sense to reduce risk or mitigate consequences.

    \subsection{Risk Consequence Table}
      A risk consequence table has a list of objectives (e.g. creating a product users like, completing the product on time) on one axis
      and a list of failure modes (e.g. requirements, project management, technical or dependency failures) on the other axis. Each cell in the
      table is assigned a value from 0 to 1 that estimates the impact of losing a particular objective for a particular failure mode. Rows and
      columns can be summed up to determine the overall likelihood of losing a particular objective and the criticality of each failure mode. Each
      objective and failure mode can also be assigned a weighting.

    \subsection{Risk Management}
      Risk management attempts to manage the degree to which projects are exposed to risks of quality, delay or failure. Sample risk management
      techniques include assessment (e.g. identification, analysis, prioritization), avoidance, and control (e.g. management planning, resolution,
      monitoring).

    \subsection{Risk Countermeasures Table}
      A risk countermeasures table is structured similarly to a risk consequence table. However, instead of listing objectives, countermeasures are
      listed instead. Each cell is assigned a value from 0 to 1 that estimates the reduction of a particular risk using that particular countermeasure.

      A set of countermeasures should be selected with join effectiveness and cost in mind.

    \subsection{Residual Risk}
      Residual risk is a kind of risk that is expected to remain even after all risk countermeasures are taken. Some residual risk is acceptable for a
      project; the purpose of countermeasures is to mitigate risk where possible.

  \section{Specifications}

    \subsection{Terminology}
      \begin{itemize}
        \item An \textbf{environment} is the part of the outside world that is relevant to some system.
        \item An \textbf{interface} refers to phenomena shared between the system and the environment.
        \item A \textbf{requirement} is a condition or capability to be achieved in the environment.
        \item A \textbf{system} is a proposed solution for achieving requirements. Interactions with the outside environment are performed
          through an interface.
        \item A \textbf{specification} is a description of a proposed system.
      \end{itemize}

    \subsection{Requirements vs Specifications}
      Requirements are statements of desired properties. They describe changes to an environment without referring to a system. These descriptions are often
      high-level and get elaborated on as development progresses.

      Specifications are descriptions of how a proposed system should behave to satisfy requirements. These are typically expressed in terms of a system's
      interface, and tend to be more concrete and detailed than requirements.

    \subsection{Deriving Requirements from Specifications}
      It is often useful for a set of specifications (Spec) to logically imply to set of requirements (Req). However, this is often not possible without additional
      information or assumptions on how the environment behaves. These domain assumptions (Dom) combined with specifications being able to determine requirements
      can be considered to be a fundamental law of requirements.

      $$ Dom, Spec \implies Req $$

    \subsection{Deriving Specifications}
      Specifications can also be derived with the help of a set of requirements and domain assumptions. The following is considered for each requirement:
      \begin{itemize}
        \item Determine any specs that for how the system should control the environment to meet this requirement. This may require adding interface phenomena
          so that the system can perform the necessary interactions with the environment.
        \item Determine any domain assumptions necessary to link environmentally-controlled phenomena to system-controlled phenomena.
      \end{itemize}

      Once these specifications are determined, the following should hold:
      $$ Dom, Spec \implies Req $$
      $$ Dom \land Spec \text{ is satisfiable}$$

  \section{Object Constraint Language (OCL)}
    A business rule is an assertion that defines or constrains some aspect of work. Examples include:
    \begin{itemize}
      \item Rental agreements must be no longer than four weeks.
      \item Frequent customers receive a 10\% discount.
    \end{itemize}

    Object Constraint Language (OCL) can be used to express business rules over UML models. OCL allows for relating classes even when they have no direct UML
    association, and for expressing queries over objects and collections of objects. Types of OCL constraints and expressions include:
    \begin{itemize}
      \item Invariant properties about objects, links, and attribute values
      \item Initial variable or attribute values
      \item Pre/post conditions of functions
      \item Guard conditions and assignment expressions in state machine models
    \end{itemize}

    \subsection{Constraint Expressions}
      OCL allows for expressions over:
      \begin{itemize}
        \item Attributes
        \item Navigations derived from associations and aggregations
        \item Rolename on far end of association
        \item Class name on far end of association
        \item Literal values
      \end{itemize}

    \subsection{Operations on Collections}
      While model-defined names and OCL operations are prefaced with dots, OCL operations on collections are prefaced with arrows (-$>$).
      For example, a sample OCL expression that counts the number of vehicles in a rental agreement is self.RentalAgreement.Vehicle-$>$size()

    \subsection{Filtering Operations}
      Filtering operations extract specific elements from an existing collection based on the value of some expression. The select operation
      returns all values that satisfy an expression, while reject returns all values that falsify that expression. A sample filtering operation
      that selects all red cars in a company is self.owns-$>$select(color=``red'')

    \subsection{Collect Operation}
      A collect operation iterates over a collection, computes a value for each element, and returns that value in a new collection. A sample
      use of a collect operation that returns the prices of rental agreements is self.RentalAgreement-$>$collect(price)

    \subsection{Quantification}

      \subsubsection{Exists}
        The exists operation is used to assert that at least one element in a collection satisfies some expression. An example of an exists
        operation that asserts every rental agreement has at least one black car is self.RentalAgreement.Vehicle-$>$exists(color=``black'')

      \subsubsection{Forall}
        The forall operation is used to assert that all elements in a collection satisfy some expression. An example of an forall operation
        that asserts all rental cars are white is self.owns-$>$forall(color=``white'')

    \subsection{OCL Tools}
      OCL is supported by various types of tools, including:
      \begin{itemize}
        \item Parsers and type checkers
        \item Evaluators that check OCL expressions against UML class models
        \item Debuggers that step through an OCL expression and evaluate each subsection
        \item Code generators that translate OCL expressions into run-time assertions
      \end{itemize}

  \section{Conflict Resolution}
    Conflict refers to disagreements among a project's stakeholders.

    \subsection{Types of Conflicts}

      \subsubsection{Data Conflicts}
        Data conflicts concern multiple conflicting understandings of an issue. Data conflicts may arise as a result of misunderstanding, or
        as a result of contradictory requirements. An example would be a requirement that states that a student transcript should
        include attendance, but some other set of requirements taking up the space where attendance would be placed.

      \subsubsection{Interest Conflicts}
        Interest conflicts occur when stakeholders have different goals or interests. An example would be a province demanding that student
        attendance be tracked for accounting purposes, but students insisting that attendance not be recorded to protect their privacy.

      \subsubsection{Value Conflicts}
        Value conflicts occur when stakeholders express different preferences or belief systems (i.e. different perceptions of ``good'' and ``bad'').
        An example would be a university wanting to stack rank students in courses, but students thinking that distinctions between student
        performance are often too fine to matter.

    \subsection{Conflict Resolution Strategies}
      Various group and individual strategies can be applied to resolving conflicts. When applying these strategies, it is important to consider
      the relationship stakeholders have with one another, as well as any goals they may share.

  \section{Behavior Modeling}

    \subsection{UML State Machines}
      State machines can be used to model behavior based on the history of received inputs. UML state machines model the flow of control between
      states in a system.

      \subsubsection{States}
        States partition a system into distinct modes of operation. An example would be a turnstile having the states of open, closed, and rotating.
        A single state should have:
        \begin{itemize}
          \item Equivalence of input traces
          \item Equivalence of future behavior
          \item Distinct set of input events
          \item Distinct reactions to input events
          \item Input processing done internally
        \end{itemize}

        States can contain:
        \begin{itemize}
          \item Entry actions, which occur every time the state is entered
          \item Exit actions, which occur every time the state is exited
          \item Internal actions
        \end{itemize}

        These actions are uninterruptible. On the other hand, activities are interruptible, and are usually expected to take a substantial amount of time.

        Each state machine has an initial state. The designator of this initial state may is a pseudo-state, since no time is actually spent in the state.
        Some state machines may also have a final state, which is a real (non-pseudo) state.

      \subsubsection{Transitions}
        Transitions represent observable execution steps. A transition label may consist of the following parts:
        \begin{itemize}
          \item \textbf{event(args):} Input event that triggers transition
          \item \textbf{[condition]:} Guard condition; transition does not occur unless this expression is true
          \item \textbf{/action:} Simple, non-interruptible action performed
        \end{itemize}
        A transition with no event or condition is enabled when the source state is idle.

      \subsubsection{Inputs}
        Inputs represent events that change their environment. Common types of inputs include:
        \begin{itemize}
          \item \textbf{Time events}, which occur at a specific time (e.g. today at 8pm) or after a specified passage of time (e.g. 10 seconds after event A)
          \item \textbf{Change events}, which occur when some condition becomes true (e.g. temperature is at least 100 degrees)
        \end{itemize}

      \subsubsection{Actions}
        Actions are atomic responses to an event. Sample actions include an output message or a change to some interface phenomena.

      \subsubsection{Concurrent Regions}
        Some systems contain several ``subsystems'' with orthogonal behavior. These systems can be modeled as concurrent state machines, where multiple
        regions (i.e. substate machines) operating concurrently form a state machine for the entire system. The execution of a concurrent state machine
        is considered complete once all regions have entered a final state. Alternatively, a termination state may be used to immediately end system
        execution, even when other regions have not completed.

        Concurrent regions can interact with one another in the following ways:
        \begin{itemize}
          \item Reacting to the same input.
          \item Interacting with the same interface phenomenon.
          \item One region generating an event that another region handles as input.
          \item A transition's guard condition containing the state of a different region (not part of the formal UML spec, but can be useful).
        \end{itemize}

      \subsubsection{Other UML State Diagram Concepts}
        A few other UML state diagram details include:
        \begin{itemize}
          \item \textbf{Hierarchical States:} States with common behaviors or exiting transitions can be grouped together, and can be treated externally as a
            single state.
          \item \textbf{Determinism and priority:} Deal with handling multiple possible transitions (e.g. conditions for two different change events
            becoming true at one).
          \item \textbf{History:} Pseudo-states known as history states (depicted as H) represent the most recent active direct substate of their containing state.
            Special types of history states known as deep history states (depicted as H*) represent the most recent active leaf-substate of their containing state.
        \end{itemize}

      \subsubsection{Good Style}
        Some recommendations for state machines include:
        \begin{itemize}
          \item States should model modes of operation, and transitions should model flow of control.
          \item Fewer transitions are preferable (hierarchy can help with this).
          \item Concurrent regions should be applied if they can simplify the model.
          \item Common behavior should not be repeated (hierarchy and entry/exit actions can help with this).
        \end{itemize}

      \subsubsection{Creating Behavior Models}
        Below is a general guideline for creating behavior models:
        \begin{enumerate}
          \item Identify input and output events (can be useful to reference domain model).
          \item Partition the system into states. State types include:
            \begin{itemize}
              \item \textbf{Activity states}, where a system performs some operation
              \item \textbf{Idle states}, where a system waits for input
              \item \textbf{System modes}, where different states are used to distinguish between different event reactions
            \end{itemize}
          \item Model the behavior for each input at each state. For each state, the system's response to an event can be any of the following:
            \begin{itemize}
              \item Event can occur and is handled (transition exists).
              \item Event can occur, but results in error (transition exists to report error).
              \item Event can occur, but is ignored (no transition).
              \item Event cannot occur (no transition).
            \end{itemize}
        \end{enumerate}

      \subsubsection{Validation}
        Some important validations to carry out on UML state machines include:
        \begin{itemize}
          \item Avoiding inconsistencies (e.g. multiple transitions are not leaving a state under the same conditions)
          \item Ensuring completeness (e.g. valid input always associated with some transition)
          \item Walkthrough tests (e.g. state machine flows match use-case scenarios)
        \end{itemize}

    \subsection{Uses of State Machine Models}
      State machine models can be used to create mockups, which include rough screen contents and navigation between screens. State machines can also
      serve as navigation diagrams, where transitions are triggered by user input (e.g. mouse clicks) and the states correspond to ``screenshots'' of
      the UI.

    \subsection{Sequence Diagrams}
      Sequence diagrams illustrate the interactions between objects over time. While state diagrams describe all allowable scenarios, sequence diagrams
      only describe a single one. However, sequence diagrams can be useful in validating specific scenarios in state diagrams, and also tend to be more
      useful for communicating with customers.

  \section{Temporal Logic}

    \subsection{Overview}
      Descriptive specification notations can describe constrains on the behavior of a system. An example is OCL, which expresses constraints on object models.
      Temporal logic describes constraints on variables (e.g. environmental variables, I/O phenomena, events, states) that can vary over time. Temporal
      constraints can be effective when describing behavior that spans multiple steps.

      Examples of temporal logic expressed in natural language include:
      \begin{itemize}
        \item Dialing a phone number always results in either the call being connected or a busy-tone.
        \item If a car approaches the intersection, the light in its direction will eventually be green.
      \end{itemize}

    \subsection{States}
      A sequence of states represents the execution of a system. A state formula is a predicate logic property that is evaluated for a particular execution state.
      A state formula with a predicate logic expression $p$ being applied to a state $s$ can be expressed as $s \vDash p$.

    \subsection{Timed Logic}

      \subsubsection{Explicit Time}
        Each variable is considered to be a function of time. The execution states can be enumerated (i.e. 0, 1, 2, ...), after which each variable can be treated
        as a function of one of these states (e.g. $x(0) = 1$ means that the variable $x$ is 1 in the initial state). These expressions can also be used to relate
        variables across different states (e.g. $x(0) >= y(1)$).

        Constraints where the precise timing of events is specified as known as real-time constraints.

      \subsubsection{Implicit Time}
        Often, only the temporal ordering of events needs to be described, rather than the precise timing of each event. In this case, special connectives
        (i.e. logic operations) can be used to relate variables at different execution stages. Linear Temporal Logic (LTL) is designed for expressing
        temporal order of events and variables values while leaving time implicit.

        The temporal connectives of LTL include:
        \begin{itemize}
          \item \textbf{Henceforth ($\Box f$)}: Asserts $f$ is true in current and all future states.
          \item \textbf{Eventually ($\Diamond f$)}: Asserts $f$ is true in current or some future state.
          \item \textbf{Next ($\Circle f$)}: Asserts $f$ is true in next future state.
          \item \textbf{Until ($f U g$)}: Asserts $g$ is eventually true, and $f$ is true until $g$ is true.
          \item \textbf{Unless ($f W g$)}: Asserts $f$ is true until $g$ is true, but with no guarantee that $g$ will become true (often used to describe environmental
            properties out of system control instead of system properties).
        \end{itemize}

  \section{Estimations}

    \subsection{Terminology}
      \begin{itemize}
        \item \textbf{Estimate:} A predication of some aspect of a project, such as its length or cost
        \item \textbf{Target:} Some desirable business objective
        \item \textbf{Commitment:} A promise to deliver
      \end{itemize}

    \subsection{Purpose}
      Estimating the cost and effort of projects has many purposes, including:
      \begin{itemize}
        \item Assessing economic feasibility
        \item Understanding resource needs
        \item Providing a basis for agreeing to a job and making realistic commitments
      \end{itemize}

    \subsection{Inaccurate Estimates}
      A business environment where ``pricing to win'' is awarded means that competitors are inclined to show unrealistically optimistic estimates to clients
      to win contracts.

      Underestimating cost tends to lead to non-linear increases in actual project effort required (i.e. if a cost estimate is 80\% of the actual cost, the
      final cost will likely be more than just the additional 20\%). This is often a result of bad planning and high-risk practices to try to complete a project
      quickly or with limited resources.

      Overestimating cost can also lead to slight increases in project cost due to Parkinson's Law, which is an adage that states ``work expands so as to fill
      the time available for its completion''.

    \subsection{Estimation Error}
      Common sources of estimation error include:
      \begin{itemize}
        \item \textbf{Uncertainty:} In a project's early stages, many requirements details and design decision remain unclear. Uncertainty tends to be decreased
          rapidly in the early stages (e.g. first 30\%) of a project.
        \item \textbf{Omitted Activities:} These omissions can include requirements/functionality, software development activities (e.g. integration, testing),
          or other not related to software development (e.g. employee vacations, company schedule).
        \item \textbf{Optimism:} Estimates by developers tend to be overly optimistic by around 20\%-30\%. These estimations are fueled by beliefs that a
          project can be completed faster than previous ones because its team is more experienced, which in theory should lead to increased productivity,
          fewer mistakes and a smaller learning curve.
        \item \textbf{Bias:} Managers can be inclined to align estimates with their desired targets.
        \item \textbf{Subjectivity:} Ambiguous requirements can lead to multiple interpretations.
        \item \textbf{Project Size:} Software projects tend to have diseconomies of scale; larger projects require more communication and coordination,
          so adding additional resources follows the law of diminishing returns.
        \item \textbf{Software Type:} Requirements elicitation and the development process is done differently for different types of projects
          (e.g. business applications, embedded applications, etc.).
        \item \textbf{Personnel Factors:} Individual productivity can vary hugely. Personnel performance can be difficult to predict, especially with
          little information on historical performance.
      \end{itemize}

    \subsection{Estimation Techniques}
      Forming estimates based on data is typically better than relying on expert judgement. Data that can be useful in forming estimates includes:
      \begin{itemize}
        \item \textbf{Project data:} Includes project size (lines of code (LOC) and requirements), resources, and time.
        \item \textbf{Historical data:} Data on previous projects in the organization.
        \item \textbf{Industry data:} Data from other organizations that develop similar systems.
      \end{itemize}

      \subsubsection{Using Analogies}
        Estimating using analogies involves decomposing a project into smaller elements that are analogous to elements of past projects
        (e.g. use cases, user interfaces, etc.). The estimates for the effort for completing all elements is based on previous effort
        for completing analogous elements.

      \subsubsection{Function Point Analysis}
        Function point analysis involves forming estimates based on a product's requirements. Function point analysis follows three steps:
        \begin{enumerate}
          \item Estimating the number of function points from the requirements. The number of function points is gathered from multiplying
            each input or output (e.g. external IO, interfaces, API, queries) by a complexity multiplier.
          \item Estimating code size from the number of function points. This is done on a language-by-language basis.
          \item Estimating resources required from the code size.
        \end{enumerate}

      \subsubsection{Software Tools}
        Some software tools can apply computationally intensive estimation methods based on large pools of data that can:
        \begin{itemize}
          \item Simulate project outcomes.
          \item Perform probability analysis on estimates.
          \item Estimate effort needed for project.
        \end{itemize}

      \subsubsection{Expert Judgement}
        Estimates based on expert judgment are typically less reliable than estimates based on data. If collecting expert judgments,
        the following should be considered:
        \begin{itemize}
          \item People actually working on the project put together the most accurate estimates.
          \item It helps to decompose project estimations into estimations for smaller subtasks.
          \item It helps to estimate a range of values (best case, most likely case, worst case). The program evaluation and review (PERT)
            technique estimates the expected value as $\frac{bestCase + 4 \cdot mostLikelyCase + worstCase}{6}$.
        \end{itemize}

    \subsection{Estimating Effort}
      Once project size is determined, the effort required can be estimated in various ways. One simple way is to compare to past projects using
      $effort = pastEffort \cdot \frac{size}{pastSize}$. More complicated (non-linear) formula can be used when larger pools of data are available
      (e.g. something like $staffMonths = 0.157 \cdot functionPoints^{0.591} \cdot teamSize^{0.81}$).

    \subsection{Estimating Schedule}
      Scheduling equations can be used to estimate the schedule of projects. For medium-to-large projects in an early phase, the schedule length
      can be estimated as $C \cdot staffMonths^{\frac{1}{3}}$, where $C$ is a constant between $2$ and $4$.

      When historical data is available, the schedule length can be estimated as $pastSchedule \cdot (\frac{estimatedEffort}{pastEffort})^d$.
      $d$ various between $\frac{1}{3}$ (for large projects) to $\frac{1}{2}$ (for small projects).

      Note that these techniques assume a project can increase its staffing, which in practice is often not possible.

    \subsection{Best Practices}
      A few recommended practices when forming estimations are:
      \begin{itemize}
        \item Decomposing a task into multiple subtasks; smaller tasks are easier to estimate, and estimation errors can sometimes cancel each other out.
        \item Using multiple estimation techniques and comparing results.
        \item Defining a clear estimation procedure in advance (e.g techniques to use, where to get data, when to re-estimate).
      \end{itemize}

    \subsection{Combining Piecewise Estimates}
      Piecewise estimates can be combined by finding the total of their estimates (e.g. best case, worst case). The variance between
      the best and worst cases for each piece can be found and summed; a confidence interval can then be constructed based on the total
      best cases, worst cases and variance.

    \subsection{Project Control}
      Once project estimates are made, the project can be controlled to meet its target by:
      \begin{itemize}
        \item Removing non-critical requirements.
        \item Redefining requirements.
        \item Improving or replacing personnel.
      \end{itemize}

      If an initial target and estimate are close to one another (e.g. within 20\%), then it should be possible to apply the above techniques
      to meet the target without drastically altering the project.

\end{document}
